# 浏览器页面加载流程

- URL 解析
- DNS 解析
- TCP 链接
- 服务器处理
- 接受响应
- 页面渲染

## URL 解析

>- 验证url 是否合法（url 组成）
>
> scheme://user:password@host:port/path?query#frag   
>
> scheme： 协议方案  
>
> >http:超文本转移协议，我们浏览网站都是这个
> > https:安全的http连接，在应用层和传输层中间加了SSL层
> > mailto:通过该链接可以在Internet中发送邮件
> > ftp:文件传输协议,传输文件
> > rtsp.rtspu :这个可能看见的少，是因为这是流传输，譬如视频流  
>
> user:password: 权限访问时使用的账号密码  
>
> Host: ip 或者 domain （域名）  
>
> Port: 端口  
>
> query：查询字符串
>
> frag：HTML 资源定位
>
>- HSTS 
>
>  >由于安全隐患，会使用HSTS强制客户端使用HTTPS 访问页面。（选择性使用） 
>
>- 其它操作（浏览器进行安全检查 访问限制 检查缓存） 
>
>  >检查缓存：
>  >
>  >![image-20191202132517854](https://gitee.com/caoguangyao/upic/raw/master/uPic/image-20191202132517854.png)
>  >
>  >

## DNS 解析

>### 基本步骤
>
>浏览器缓存 -- 操作系统缓存--路由器缓存--isp dns 缓存-- 根域名服务器
>
>- 浏览器缓存
>
>  浏览器会先检查是否在缓存中，没有则调用系统库函数进行查询
>
>- 操作系统缓存 
>
>  操作系统也有自己的DNS缓存，但在这之前，会向检域名是否存在本地HOST文件里，没有则向DNS 服务器发送查询请求
>
>- 路由器缓存
>
>  路由器 也有自己的缓存
>
>- ISP DNS 缓存
>
>  ISP DNS 就是在客户端电脑上设置的首选DNS服务器，大多数情况下都会有缓存  
>
>- 根域名服务器查询
>
>  在前面所有步骤没有缓存的情况下，本地DNS服务器将请求转发到互联网上的根域。

## TCP链接

  TCP/IP 分为四层，在发送数据时，每层都要对数据进行封装：

![tcp-ip](https://gitee.com/caoguangyao/upic/raw/master/uPic/tcp-ip.png)

### 应用层：发送HTTP请求

得到服务器的IP地址，浏览器会开始构造一个HTTP报文，其中包括：

>- 请求报头（Request Header）: 请求方法、目标地址、遵循的协议等等
>- 请求主体（其它参数）
>
>浏览器只能发送 GET， POST 方法，打开网页使用的是 GET

### 传输层：TCP 传输报文

>传输层会发起一条到达服务器的TCP连接，为了方便传输，会对数据进行分割（以报文段为单位），并标记编号，方便服务器接收时能够准确的还原报文信息。
>
>在建立连接之前，会进行TCP 三次握手。

### 网络层：IP协议查询Mac地址

>将数据段打包，并加入源及目标的IP地址，并且负责寻找传输路线。
>
>判断目标地址是否与当前地址处于同一网络中，是的话直接根据Mac地址发送，否则使用路由表查找下一跳地址，以及使用ARP协议查询它的Mac地址。 

### 链路层：以太网协议

>根据以太网协议将数据分为以“帧”为单位的数据包，每一帧分为两部分：
>
>- 标头：数据包的发送者、接受者、数据类型
>- 数据：数据包具体内容
>
>Mac 地址
>
>以太网规定了连入网络的所有设备都必须具备“网卡”接口，数据包都是从一块网卡传递到另外一块网卡，网卡的地址信息就是mac 地址。每一个mac地址都是独一无二的，具备了一对一的能力。
>
>广播：
>
>发送数据的方式很原始，直接报数据通过 ARP 协议，向本网络所有机器发送，接收方根据标头信息与自身mac 地址比较，一致就接收，否则丢弃。
>
>（接收方回应是单播    ARP 攻击） 

### 服务器接受请求

#### 大致流程

![Snipaste_2019-12-03_10-54-34](https://gitee.com/caoguangyao/upic/raw/master/uPic/Snipaste_2019-12-03_10-54-34.png)

#### HTTPD

最常见的HTTPD有Linux上常用的Apache和Nginx，以及Windows上的IIS。   

它会监听得到的请求，然后开启一个子进程去处理这个请求。

#### 处理请求

接收TCP报文后，会对连接进行处理，对HTTP协议进行解析（请求方法、域名、路径等），并进行一些验证：

- 验证是否配置虚拟主机
- 验证虚拟主机是否接受此方法
- 验证该用户可以使用该方法（根据IP地址、身份信息等）

#### 重定向





#### URL 重写





### 浏览器接受响应

接收到服务端的响应资源后，对资源进行分析。

查看 Response header，根据不同状态码做不同的事（比如上面的重定向）。

如果响应资源进行了压缩（比如 gzip），还需要进行解压

然后对响应资源做缓存。

根据响应资源里的MIME 类型去解析响应内容（比如 HTML Image 各有不同的解析方式）



###  渲染页面

不同的浏览器内核，渲染过程也不完全相同，大致流程相近

![Snipaste_2019-12-03_13-53-53](https://gitee.com/caoguangyao/upic/raw/master/uPic/Snipaste_2019-12-03_13-53-53.png)



#### HTML 解析

浏览器的解析是从上往下 一行一行解析的。

大致可分为四个步骤：

1. 解码 （encoding） 

   传输回来的其实都是一些二进制字节数据，浏览器需要根据文件指定编码（例如UTF-8）转换成字符串，也就是HTML 代码。  

2. 预解析 （pre-parsing）

   预解析做的事情是提前加载资源，减少处理时间，它会识别一些会请求资源的属性，比如`img`标签的`src`属性，并将这个请求加到请求队列中。

3. 符号化 （tokenization）

   符号化是词法分析的过程，将输入解析成符号，HTML 符号包括，开始标签、结束标签、属性名和属性值。

   它通过一个状态机去识别符号的状态，比如遇到`<`，`>`状态都会产生变化。

4. 构建树 （tree construction）

   在上一步符号化中，解析器获得这些标记，然后以合适的方法创建`DOM`对象并把这些符号插入到`DOM`对象中。

#### 事件

当整个解析的过程完成以后，浏览器会通过`DOMContentLoaded`事件来通知`DOM`解析完成。

#### CSS 解析

一旦浏览器下载了 CSS，CSS 解析器就会处理它遇到的任何 CSS，根据**语法规范**[4]解析出所有的 CSS 并进行标记化，然后我们得到一个规则表。

**CSS 匹配规则**

在匹配一个节点对应的 CSS 规则时，是按照从右到左的顺序的，例如：`div p { font-size :14px }`会先寻找所有的`p`标签然后判断它的父元素是否为`div`。

所以我们写 CSS 时，尽量用 id 和 class，千万不要过度层叠。

#### 渲染树

其实这就是一个 DOM 树和 CSS 规则树合并的过程。

```markdown
注意： 渲染树会忽略那些不需要渲染的节点，比如设置了 display：none 的节点
```

#### 计算

通过计算让任何尺寸值都减少到三个可能之一： auto 、百分比、px，比如把 rem 转化为 px。

#### 级联

浏览器需要一种方法来确定哪些样式才真正需要应用到对应元素，所以它使用一个叫做`specificity`的公式，这个公式会通过：

1. 标签名、class、id
2. 是否内联样式
3. !important`

然后得出一个权重值，取最高的那个。

#### 阻塞（解析/渲染 阻塞？？）

js 生效时间，生成document 时就 就生效了， 生成 document 后 开始解析 html。 

当遇到一个`script`标签时，DOM 构建会被暂停，直至脚本完成执行，然后继续构建 DOM 树。DOM构建以及css树构建 ，此时 document.readyState = loading

但如果 JS 依赖 CSS 样式，而它还没有被下载和构建时，浏览器就会延迟脚本执行，直至 CSS Rules 被构建。

所以我们知道：

- CSS 会阻塞 JS 执行
- JS 会阻塞后面的 DOM 解析

为了避免这种情况，应该以下原则：

- CSS 资源排在 JavaScript 资源前面
- JS 放在 HTML 最底部

另外，如果要改变阻塞模式，可以使用 defer 与 async

```html
/*
* 浏览器 开始加载页面时 开始 - 结束完毕 按顺序 发生的每一件事情 的总流程
* 1 生成 document【此时js 开始起作用】
* 2 解析文档 从 html 第一行 阅读到 最后一行（老的浏览器 只是读一遍） 中间 构建 dom 树 同时     document.readyState == 'loading'
*   如果有 link 标签 开新线程【js开启的】
*   异步加载外部css 文件 （包括style） 后 构建 cssdom 树
* 3 没有设置异步加载的 script 标签时 阻塞 文档解析，等待js脚本加载 并执行后 继续解析文档
* 4 遇到 异步加载的script ，异步加载 js 脚本，不阻塞文档解析【异步脚本里不可以 直接写 document.write()】
* 5 解析文档时 遇到 img 时 先解析 img 节点，src 创建加载线程 异步加载图片资源 不阻塞 解析文档
*
* 7 文档解析完成 如有 defer script js 脚本开始按照顺序执行 document.readyState == 'interactive' 交互
* 8 解析完成 执行 DOMContentLoaded 事件
* 9  程序：同步的脚本执行阶段 --> 事件驱动阶段
* 10 async script 加载并执行完毕 （执行顺序不定~~）,img 等资源加载完毕之后  window 对象的 onload 事件才会触发
*
* document.readyState == 'complete' 加载完成
* */
```



#### 布局与绘制

确定渲染树种所有节点的几何属性，比如：位置、大小等等，最后输入一个盒子模型，它能精准地捕获到每个元素在屏幕内的准确位置与大小。

然后遍历渲染树，调用渲染器的 paint() 方法在屏幕上显示其内容。

##### 合并渲染层

把以上绘制的所有图片合并，最终输出一张图片。

##### 回流与重绘

**回流(reflow)**

当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从`html`标签开始递归往下，重新计算位置和大小。

reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。

**重绘(repaint)**

改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。

每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。

回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。

比如：

- `display:none` 会触发回流，而 `visibility:hidden` 只会触发重绘。

